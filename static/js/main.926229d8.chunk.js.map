{"version":3,"sources":["utils/node.ts","utils/filter.ts","components/FilterHeader.tsx","components/SelectedButtonNode.tsx","components/ButtonNode.tsx","components/NonTerminalNode.tsx","components/LinkNode.tsx","components/TooltipNode.tsx","components/TerminalNode.tsx","components/NodeView.tsx","components/MapView.tsx","components/MapSourceUrl.tsx","App.tsx","utils/parameter.ts","serviceWorker.ts","index.tsx"],"names":["getNodeFrom","body","selectedNodeKeys","filters","applyFilter","node","level","condition","result","Object","keys","nodeKey","includes","some","each","applyFilterFrom","i","selectedNodeKey","FilterHeader","placeholder","onKeyUp","type","SelectedButtonNode","nodeValue","className","length","ButtonNode","onNodeKeySelected","onClick","NonTerminalNode","LinkNode","text","link","href","title","target","TooltipNode","tooltip","TerminalNode","value","test","NodeView","model","entries","filter","sort","a","b","map","key","MapView","headers","newNullArray","Array","fill","useState","setSelectedNodeKeys","setFilters","getNode","updateFilters","newValue","old","index","updateFiltersFrom","updateSelectedNodeKeys","newKey","updateSelectedNodeKeysFrom","header","event","newNodeKey","MapSourceUrl","url","setUrl","defaultValue","onKeyPress","undefined","App","window","location","search","URLSearchParams","get","setMap","useEffect","fetch","then","r","json","data","catch","error","console","alert","message","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.926229d8.chunk.js","sourcesContent":["import { IMapNode } from \"../models/node\";\r\nimport { applyFilterFrom } from \"./filter\";\r\n\r\nexport const getNodeFrom = (\r\n  body: IMapNode,\r\n  selectedNodeKeys: Array<string | null>,\r\n  filters: Array<string | null>\r\n) => {\r\n  const applyFilter = applyFilterFrom(filters);\r\n  return (level: number) => {\r\n    let node: IMapNode | undefined = applyFilter(body, 0);\r\n    for (let i = 0; i < level; i++) {\r\n      const selectedNodeKey = selectedNodeKeys[i];\r\n      if (!node || !selectedNodeKey) {\r\n        return undefined;\r\n      }\r\n      node = applyFilter(node[selectedNodeKey] as IMapNode, i + 1);\r\n    }\r\n    return node;\r\n  };\r\n};\r\n\r\nexport const updateSelectedNodeKeysFrom = (\r\n  selectedNodeKeys: Array<string | null>\r\n) => (level: number, newKey: string) =>\r\n  selectedNodeKeys.map((old, index) =>\r\n    index < level ? old : index === level ? newKey : null\r\n  );\r\n","import { IMapNode } from \"../models/node\";\r\n\r\nexport const applyFilterFrom = (filters: Array<string | null>) => (\r\n  node: IMapNode,\r\n  level: number\r\n) => {\r\n  if (!node) {\r\n    return node;\r\n  }\r\n  const condition = filters[level];\r\n  if (!condition) {\r\n    return node;\r\n  }\r\n  const result: IMapNode = {};\r\n  for (const nodeKey of Object.keys(node)) {\r\n    if (\r\n      nodeKey.includes(condition) ||\r\n      (typeof node[nodeKey] !== \"string\" &&\r\n        Object.keys(node[nodeKey]).some(each => each.includes(condition)))\r\n    ) {\r\n      result[nodeKey] = node[nodeKey];\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexport const updateFiltersFrom = (filters: Array<string | null>) => (\r\n  level: number,\r\n  newValue: string\r\n) => filters.map((old, index) => (index !== level ? old : newValue));\r\n","import React from \"react\";\r\n\r\nconst FilterHeader: React.SFC<{\r\n  placeholder?: string;\r\n  onKeyUp?: (event: React.KeyboardEvent<HTMLInputElement>) => void;\r\n}> = ({ placeholder, onKeyUp }) => (\r\n  <input type=\"text\" onKeyUp={onKeyUp} placeholder={placeholder} />\r\n);\r\n\r\nexport default FilterHeader;\r\n","import React from \"react\";\r\nimport { IMapNode } from \"../models/node\";\r\n\r\nconst SelectedButtonNode: React.SFC<{\r\n  nodeKey: string;\r\n  nodeValue: IMapNode;\r\n}> = ({ nodeKey, nodeValue }) => (\r\n  <button className=\"selected\">\r\n    {nodeKey}\r\n    <span className=\"count\">({Object.keys(nodeValue).length})</span>\r\n  </button>\r\n);\r\n\r\nexport default SelectedButtonNode;\r\n","import React from \"react\";\r\nimport { IMapNode } from \"../models/node\";\r\n\r\nconst ButtonNode: React.SFC<{\r\n  nodeKey: string;\r\n  nodeValue: IMapNode;\r\n  onNodeKeySelected: (nodeKey: string) => void;\r\n}> = ({ nodeKey, nodeValue, onNodeKeySelected }) => (\r\n  <button onClick={() => onNodeKeySelected(nodeKey)}>\r\n    {nodeKey}\r\n    <span className=\"count\">({Object.keys(nodeValue).length})</span>\r\n  </button>\r\n);\r\n\r\nexport default ButtonNode;\r\n","import React from \"react\";\r\nimport SelectedButtonNode from \"./SelectedButtonNode\";\r\nimport ButtonNode from \"./ButtonNode\";\r\nimport { IMapNode } from \"../models/node\";\r\n\r\nconst NonTerminalNode: React.SFC<{\r\n  nodeKey: string;\r\n  nodeValue: IMapNode;\r\n  selectedNodeKey: string | null;\r\n  onNodeKeySelected: (nodeKey: string) => void;\r\n}> = ({ nodeKey, nodeValue, selectedNodeKey, onNodeKeySelected }) =>\r\n  selectedNodeKey === nodeKey ? (\r\n    <SelectedButtonNode nodeKey={nodeKey} nodeValue={nodeValue} />\r\n  ) : (\r\n    <ButtonNode nodeKey={nodeKey} nodeValue={nodeValue} onNodeKeySelected={onNodeKeySelected} />\r\n  );\r\n\r\nexport default NonTerminalNode;\r\n","import React from \"react\";\r\n\r\nconst LinkNode: React.SFC<{ text: string; link: string }> = ({\r\n  text,\r\n  link\r\n}) => (\r\n  // eslint-disable-next-line\r\n  <a className=\"link\" href={link} title={link} target=\"_blank\">\r\n    {text}\r\n  </a>\r\n);\r\n\r\nexport default LinkNode;\r\n","import React from \"react\";\r\n\r\nconst TooltipNode: React.SFC<{ text: string; tooltip: string }> = ({\r\n  text,\r\n  tooltip\r\n}) => (\r\n  <span className=\"link\" title={tooltip}>\r\n    {text}\r\n  </span>\r\n);\r\n\r\nexport default TooltipNode;\r\n","import React from \"react\";\r\nimport LinkNode from \"./LinkNode\";\r\nimport TooltipNode from \"./TooltipNode\";\r\n\r\nconst TerminalNode: React.SFC<{ text: string; value: string }> = ({\r\n  text,\r\n  value\r\n}) =>\r\n  /^(http|\\/|\\.)/i.test(value) ? (\r\n    <LinkNode text={text} link={value} />\r\n  ) : (\r\n    <TooltipNode text={text} tooltip={value} />\r\n  );\r\n\r\nexport default TerminalNode;\r\n","import React from \"react\";\r\nimport NonTerminalNode from \"./NonTerminalNode\";\r\nimport TerminalNode from \"./TerminalNode\";\r\nimport { IMapNode } from \"../models/node\";\r\n\r\nconst NodeView: React.SFC<{\r\n  model: IMapNode;\r\n  selectedNodeKey: string | null;\r\n  onNodeKeySelected: (nodeKey: string) => void;\r\n}> = ({ model, selectedNodeKey, onNodeKeySelected }) => (\r\n  <ul>\r\n    {Object.entries(model)\r\n      .filter(([, nodeValue]) => typeof nodeValue !== \"string\")\r\n      .sort((a, b) => Object.keys(b[1]).length - Object.keys(a[1]).length)\r\n      .map(([nodeKey, nodeValue]) => (\r\n        <li key={nodeKey}>\r\n          <NonTerminalNode\r\n            nodeKey={nodeKey}\r\n            nodeValue={nodeValue as IMapNode}\r\n            selectedNodeKey={selectedNodeKey}\r\n            onNodeKeySelected={onNodeKeySelected}\r\n          />\r\n        </li>\r\n      ))}\r\n    {Object.entries(model)\r\n      .filter(([, nodeValue]) => typeof nodeValue === \"string\")\r\n      .map(([nodeKey, nodeValue]) => (\r\n        <li key={nodeKey}>\r\n          <TerminalNode text={nodeKey} value={nodeValue as string} />\r\n        </li>\r\n      ))}\r\n  </ul>\r\n);\r\n\r\nexport default NodeView;\r\n","import React, { useState } from \"react\";\r\nimport { IMap } from \"../models/map\";\r\nimport { getNodeFrom, updateSelectedNodeKeysFrom } from \"../utils/node\";\r\nimport FilterHeader from \"./FilterHeader\";\r\nimport NodeView from \"./NodeView\";\r\nimport { updateFiltersFrom } from \"../utils/filter\";\r\n\r\nconst MapView: React.SFC<{ map: IMap }> = ({ map: { headers, body } }) => {\r\n  const newNullArray = () => Array(headers.length).fill(null);\r\n  const [selectedNodeKeys, setSelectedNodeKeys] = useState<\r\n    Array<string | null>\r\n  >(newNullArray());\r\n  const [filters, setFilters] = useState<Array<string | null>>(newNullArray());\r\n\r\n  const getNode = getNodeFrom(body, selectedNodeKeys, filters);\r\n  const updateFilters = updateFiltersFrom(filters);\r\n  const updateSelectedNodeKeys = updateSelectedNodeKeysFrom(selectedNodeKeys);\r\n  return (\r\n    <div className=\"row\">\r\n      {headers.map((header, level) => {\r\n        const model = getNode(level);\r\n        return (\r\n          <div key={header} className=\"column\">\r\n            <FilterHeader\r\n              placeholder={header}\r\n              onKeyUp={event =>\r\n                setFilters(\r\n                  updateFilters(level, (event.target as HTMLInputElement).value)\r\n                )\r\n              }\r\n            />\r\n            {model && (\r\n              <NodeView\r\n                model={model}\r\n                selectedNodeKey={selectedNodeKeys[level]}\r\n                onNodeKeySelected={newNodeKey =>\r\n                  setSelectedNodeKeys(updateSelectedNodeKeys(level, newNodeKey))\r\n                }\r\n              />\r\n            )}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MapView;\r\n","import React from \"react\";\r\n\r\nconst MapSourceUrl: React.SFC<{\r\n  url: string | null;\r\n  setUrl: (newUrl: string) => void;\r\n}> = ({ url, setUrl }) => (\r\n  <div className=\"sourceUrl\">\r\n    <input\r\n      type=\"text\"\r\n      defaultValue={url || \"\"}\r\n      placeholder=\"Map JSON URL\"\r\n      onKeyPress={event =>\r\n        event.key === \"Enter\"\r\n          ? setUrl((event.target as HTMLInputElement).value)\r\n          : undefined\r\n      }\r\n    />\r\n  </div>\r\n);\r\n\r\nexport default MapSourceUrl;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport \"./App.css\";\r\nimport MapView from \"./components/MapView\";\r\nimport { IMap } from \"./models/map\";\r\nimport MapSourceUrl from \"./components/MapSourceUrl\";\r\nimport { getMapUrlFromQueryString } from \"./utils/parameter\";\r\n\r\nconst App: React.SFC = () => {\r\n  const [url, setUrl] = useState<string | null>(getMapUrlFromQueryString());\r\n  const [map, setMap] = useState<IMap | null>(null);\r\n  useEffect(() => {\r\n    if (url) {\r\n      fetch(url)\r\n        .then(r => r.json())\r\n        .then(data => setMap(data))\r\n        .catch(error => {\r\n          setMap(null);\r\n          console.error(error);\r\n          alert(error.message);\r\n        });\r\n    }\r\n  }, [url]);\r\n  return (\r\n    <div className=\"app\">\r\n      <MapSourceUrl url={url} setUrl={setUrl} />\r\n      {map && <MapView map={map} />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","export const getMapUrlFromQueryString = () => {\r\n  if (!window || !window.location || !window.location.search) {\r\n    return null;\r\n  }\r\n  const urlParams = new URLSearchParams(window.location.search);\r\n  return urlParams.get(\"map\");\r\n};\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}